import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,f as s,o as t}from"./app-J--cab32.js";const i={};function o(c,e){return t(),n("div",null,e[0]||(e[0]=[s(`<h1 id="服务器生存指南" tabindex="-1"><a class="header-anchor" href="#服务器生存指南"><span>服务器生存指南</span></a></h1><blockquote><p>坐拥8张A6000，500GB运行内存，却仍然无法顺畅地进行实验？是的，这样的悲剧切切实实地发生在课题组内的每个同学身上。本篇将记录在多人共享的服务器上生存的若干tricks。</p></blockquote><h2 id="no-space-left-on-device" tabindex="-1"><a class="header-anchor" href="#no-space-left-on-device"><span>No Space Left on Device</span></a></h2><h3 id="合理存放-data-与-code" tabindex="-1"><a class="header-anchor" href="#合理存放-data-与-code"><span>合理存放 data 与 code</span></a></h3><p>一般来说，实验服务器会将存储空间划分为 code 和 data 两部分，分别挂载不同的磁盘。其中，data 部分对应的存储空间远大于 code 部分。以我所使用的服务器为例，<code>df -h</code> 的输出如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Filesystem      Size  Used Avail Use% Mounted on</span></span>
<span class="line"><span>udev            252G     0  252G   0% /dev</span></span>
<span class="line"><span>tmpfs            51G  3.5M   51G   1% /run</span></span>
<span class="line"><span>/dev/sda3       431G  407G  2.4G 100% /</span></span>
<span class="line"><span>tmpfs           252G  401M  252G   1% /dev/shm</span></span>
<span class="line"><span>tmpfs           5.0M     0  5.0M   0% /run/lock</span></span>
<span class="line"><span>tmpfs           252G     0  252G   0% /sys/fs/cgroup</span></span>
<span class="line"><span>/dev/loop1       56M   56M     0 100% /snap/core18/2697</span></span>
<span class="line"><span>/dev/loop0      128K  128K     0 100% /snap/bare/5</span></span>
<span class="line"><span>/dev/loop2       92M   92M     0 100% /snap/gtk-common-themes/1535</span></span>
<span class="line"><span>/dev/loop3       50M   50M     0 100% /snap/snapd/18357</span></span>
<span class="line"><span>/dev/loop4      347M  347M     0 100% /snap/gnome-3-38-2004/119</span></span>
<span class="line"><span>/dev/nvme0n1    7.0T  5.4T  1.3T  82% /data1</span></span>
<span class="line"><span>/dev/loop5       64M   64M     0 100% /snap/core20/1822</span></span>
<span class="line"><span>/dev/loop7      219M  219M     0 100% /snap/gnome-3-34-1804/77</span></span>
<span class="line"><span>/dev/loop6       46M   46M     0 100% /snap/snap-store/638</span></span>
<span class="line"><span>/dev/sda1       734M  158M  524M  24% /boot</span></span>
<span class="line"><span>/dev/sdb1       7.3T  6.0T  937G  87% /data2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，正确的做法应该是将所有的数据集下载到 <code>/data1</code> 和 <code>/data2</code> 目录下。</p><h3 id="隐式的空间占用" tabindex="-1"><a class="header-anchor" href="#隐式的空间占用"><span><strong>隐式的空间占用</strong></span></a></h3><p>在安装环境、下载模型等过程中，<strong>临时目录和缓存</strong>会隐式占用磁盘空间。不同的库会有不同的路径设置逻辑，同一库的不同版本间，占用路径的设置也会有区别，需时刻查阅手册。这里列举较为常见的例子：</p><h4 id="修改-conda-env-的安装路径" tabindex="-1"><a class="header-anchor" href="#修改-conda-env-的安装路径"><span>修改 conda env 的安装路径</span></a></h4><p>由于课题组的研究方向是CV，不可避免的会用到 pytorch 库，因此即使只在 <code>/home</code> 目录下存放 code 以及安装环境，也会占用很多空间。</p><blockquote><p>正确的解决方法应该是实现环境的复用，对于各用户所需的相同的 torch 版本，只保留一份 conda 环境，但这需要全体组员的协作，并且假定了在固定 torch 版本后，不存在对于某些库的不同版本的需求。</p></blockquote><p>可以通过 <code>conda create --prefix=/path/to/your/env</code> 来自定义 <code>conda env</code> 的安装路径。这样就可以逃离拥挤的 <code>/home</code> 目录。</p><h4 id="修改-pip-cache-以及-tmpdir" tabindex="-1"><a class="header-anchor" href="#修改-pip-cache-以及-tmpdir"><span>修改 pip cache 以及 TMPDIR</span></a></h4><p>修改 conda env 安装路径后，可以发现在安装环境时， <code>~/miniconda3</code> 目录大小确实不再增加，但仍然会遇到磁盘空间不足的问题。这就不得不提 pip install 过程中隐式占用的两个目录：</p><ul><li><strong>cache</strong>：用于缓存已下载的包和安装数据。pip 会将从 PyPI（Python 包索引）或其他源下载的包存储在本地缓存中，以便在下次安装相同版本的包时不需要再次下载。缓存目录位置可以通过 <code>pip cache dir</code> 命令查看，默认位于用户的主目录下的 <code>.cache/pip</code> 目录中。因此，需要通过 <code>pip config set global.cache-dir &quot;/path/to/your/cache/pip&quot;</code> 将 cache 目录也放在 /data 目录下。</li><li><strong>TMPDIR</strong>：TMPDIR 目录用于存储安装过程中生成的临时文件。pip 需要在安装包时解压压缩包、构建 wheels、编译扩展模块等，这些操作都会在临时目录中完成。当 TMPDIR 环境变量不存在时，会默认使用 <code>/var/tmp</code>，从 <code>df -h</code> 的输出可知，这与 <code>/home</code> 目录占用了同一块磁盘的空间。因此，需要设置 TMPDIR 环境变量至 <code>/path/to/your/tmp</code>。</li></ul><h4 id="修改hf-home" tabindex="-1"><a class="header-anchor" href="#修改hf-home"><span>修改HF_HOME</span></a></h4><p>Hugging Face 也会使用缓存机制来存储下载的模型等（例如 <code>from_pretrained()</code> 加载的模型），使用的缓存目录为<code>$HF_HOME/.cache/huggingface</code> 。现在的大模型 chekcpoint 动辄5GB+，是一笔很大的存储开销。既然缓存目录的定义方式使用了环境变量，我们也就不必去源码中硬编码路径了，直接设置 <code>$HF_HOME</code> 即可。</p><h4 id="修改-docker-root" tabindex="-1"><a class="header-anchor" href="#修改-docker-root"><span>修改 docker_root</span></a></h4><p>docker 的根目录（默认为 <code>/var/lib/docker</code>）是 docker 存储数据的位置。这个目录保存了与 docker 相关的所有数据，包括：</p><ul><li><strong>镜像（Images）</strong>：下载或构建的 docker 镜像被存储在该目录中。</li><li><strong>容器（Containers）</strong>：运行或停止的容器及其数据也存储在这个目录中。</li><li><strong>卷（Volumes）</strong>：如果你使用了 docker 卷来持久化数据，卷数据会保存在根目录的子目录中。</li></ul><p>在 docker 中安装环境、下载数据，所占用的正是 docker 根目录的空间。可以通过在 <code>/etc/docker/daemon.json</code> 中添加如下内容以修改 docker 根目录：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">&quot;data-root&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/path/to/your/new/docker_root&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cope-with-proxy" tabindex="-1"><a class="header-anchor" href="#cope-with-proxy"><span>Cope with Proxy</span></a></h2><p>正常情况下，为服务器配置代理是非常容易的。然而，真实情况是，实验服务器通过局域网与 Gateway Server 连通，而 Gateway Server 只开放了某端口用作流量入口，即无法通过 ssh 连接。 因此，第一跳必须是 Gateway Server，且无法在其上配置多级代理，配置代理计划落空。但绝望中仍有一线生机：</p><h3 id="使用镜像站" tabindex="-1"><a class="header-anchor" href="#使用镜像站"><span>使用镜像站</span></a></h3><p>绝大多数情况下，所需安装的库、所需下载的模型在镜像站中都会有备份。以 Hugging Face 为例，可以设置 <code>HF_ENDPOINT=&quot;https://hf-mirror.com&quot;</code> 来从镜像站拉取模型。apt、pip、conda 等也类似。</p><h3 id="离线安装" tabindex="-1"><a class="header-anchor" href="#离线安装"><span>离线安装</span></a></h3><p>可以检索库的 manual install 方式，将其中所需的源文件透过代理下载到本地，然后通过 scp 传到服务器上，再从源文件进行安装。这一方法甚至对 vscode 拓展也适用：在 <a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener noreferrer">vscode extension market</a> 找到目标插件，选择 Downoad Extension，传输到服务器后，通过 Extension -&gt; Install from VSIX... 即可离线安装插件。</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>to be extended</p></div>`,30)]))}const d=a(i,[["render",o],["__file","服务器生存指南.html.vue"]]),l=JSON.parse('{"path":"/posts/server/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97.html","title":"服务器生存指南","lang":"en-US","frontmatter":{"cover":"/assets/images/server/cover.png","icon":"pen-to-square","date":"2024-10-09T00:00:00.000Z","category":["server config"],"tag":["linux","docker","python-env","network-proxy"],"star":true,"sticky":true,"excerpt":"<p> 坐拥8张A6000，500GB运行内存，却仍然无法顺畅地进行实验？是的，这样的悲剧切切实实地发生在课题组内的每个同学身上。本篇将记录在多人共享的服务器上生存的若干tricks。 </p>","description":"服务器生存指南 坐拥8张A6000，500GB运行内存，却仍然无法顺畅地进行实验？是的，这样的悲剧切切实实地发生在课题组内的每个同学身上。本篇将记录在多人共享的服务器上生存的若干tricks。 No Space Left on Device 合理存放 data 与 code 一般来说，实验服务器会将存储空间划分为 code 和 data 两部分，分别挂...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/BlogSite/posts/server/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97.html"}],["meta",{"property":"og:site_name","content":"Site MallocSimenons"}],["meta",{"property":"og:title","content":"服务器生存指南"}],["meta",{"property":"og:description","content":"服务器生存指南 坐拥8张A6000，500GB运行内存，却仍然无法顺畅地进行实验？是的，这样的悲剧切切实实地发生在课题组内的每个同学身上。本篇将记录在多人共享的服务器上生存的若干tricks。 No Space Left on Device 合理存放 data 与 code 一般来说，实验服务器会将存储空间划分为 code 和 data 两部分，分别挂..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/BlogSite/assets/images/server/cover.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://mister-hope.github.io/BlogSite/assets/images/server/cover.png"}],["meta",{"name":"twitter:image:alt","content":"服务器生存指南"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"python-env"}],["meta",{"property":"article:tag","content":"network-proxy"}],["meta",{"property":"article:published_time","content":"2024-10-09T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"服务器生存指南\\",\\"image\\":[\\"https://mister-hope.github.io/BlogSite/assets/images/server/cover.png\\"],\\"datePublished\\":\\"2024-10-09T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MallocSimenons\\",\\"url\\":\\"https://zhangmxxx.github.io/BlogSite/\\"}]}"]]},"headers":[{"level":2,"title":"No Space Left on Device","slug":"no-space-left-on-device","link":"#no-space-left-on-device","children":[{"level":3,"title":"合理存放 data 与 code","slug":"合理存放-data-与-code","link":"#合理存放-data-与-code","children":[]},{"level":3,"title":"隐式的空间占用","slug":"隐式的空间占用","link":"#隐式的空间占用","children":[]}]},{"level":2,"title":"Cope with Proxy","slug":"cope-with-proxy","link":"#cope-with-proxy","children":[{"level":3,"title":"使用镜像站","slug":"使用镜像站","link":"#使用镜像站","children":[]},{"level":3,"title":"离线安装","slug":"离线安装","link":"#离线安装","children":[]}]}],"readingTime":{"minutes":4.98,"words":1494},"filePathRelative":"posts/server/服务器生存指南.md","localizedDate":"October 9, 2024","autoDesc":true}');export{d as comp,l as data};

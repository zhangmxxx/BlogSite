import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as r,o as i}from"./app-C_dOQEek.js";const o={};function n(l,e){return i(),t("div",null,e[0]||(e[0]=[r('<h1 id="blog-design" tabindex="-1"><a class="header-anchor" href="#blog-design"><span>Blog Design</span></a></h1><p>Sidebar、Navbar等组件的交互逻辑借鉴了 Mister-Hope 的<a href="https://github.com/Mister-Hope/Mister-Hope.github.io" target="_blank" rel="noopener noreferrer">设计思路</a>。同时，也会记录一些较为 tricky 的问题。</p><blockquote><p>其实这里已经用到了一些 tricks。</p></blockquote><h2 id="sidebar" tabindex="-1"><a class="header-anchor" href="#sidebar"><span>Sidebar</span></a></h2><p>对于一个目录 /path，有两种逻辑来显示它：</p><ul><li>对于 /path 下的每个子目录，生成一个表项。该表项只包含链接，不可展开。路由至该子目录后，重新绘制 Sidebar，显示子目录内容。</li><li>对于 /path 下的每个子目录，生成一个表项。该表项可折叠。路由至子目录后，不再重新绘制 Sidebar。</li></ul><p>对于级别较高的目录，采取第一种；对于级别较低的、接近 terminal 的目录，采取第二种，以避免展开后，Sidebar 内的内容过少。</p><p><strong>这种设计存在的问题</strong>：</p><ul><li>进入子目录后，只能在文章顶部路由回到上一级目录，在 Sidebar 中没有上一级目录的选项。</li><li>对于 /home 下的各级目录，想要切换到 sibling 目录，必须回一次 /home，这种巨大的页面风格差距会带来不良的阅读体验。</li></ul><h2 id="navbar" tabindex="-1"><a class="header-anchor" href="#navbar"><span>Navbar</span></a></h2><p>Navbar 是全局不变的。因此，相较于 Sidebar，其核心功能应该是提供快速回到高级别目录的 shortcut。（这似乎刚好解决了 Sidebar 存在的问题）。一个简单的设计思路是，将 /home 目录下的直接子目录作为 Navbar 的表项。</p><p><strong>这种设计存在的问题</strong>：</p><ul><li>对于目前的网站体量，在逻辑上似乎不足以划分为独立的模块。以 Mister-Hope 的 Navbar 为例，其表项分别为：代码笔记、随笔、软件教程。相比之下，Work、DevInit 的交叉程度较大。但在路由逻辑上，必须这样设计。</li></ul><h2 id="articles-on-mainpage" tabindex="-1"><a class="header-anchor" href="#articles-on-mainpage"><span>Articles on MainPage</span></a></h2><p>在文章的 frontmatter 中设置 <code>article: false</code> 可以将文章从主页隐去。<a href="https://theme-hope.vuejs.press/zh/config/frontmatter/info.html" target="_blank" rel="noopener noreferrer">Details</a></p><p>可以在 MainPage 上只显示每个目录的 <code>Readme.md</code>，将 ArticleList 作为一个平铺化的索引列表。但是个人认为这样与结构化的索引工具 Navbar 和 Sidebar 功能重复了，毕竟人类还是习惯于基于文件系统的树状结构进行检索。因此，在 MainPage 上只按照时间顺序放置文章，如果有额外的优先级，考虑使用 star 属性。</p><h2 id="tricks-or-bugs" tabindex="-1"><a class="header-anchor" href="#tricks-or-bugs"><span>Tricks or Bugs</span></a></h2><p>因为目前对于前端的知识了解甚少，对于遇到的问题很难判断到底是 bug 还是使用不规范引发的错误。</p><ul><li>在段落的前一行，某些格式无法正常渲染。已知 buggy 的有：站内文章的链接。</li></ul>',19)]))}const c=a(o,[["render",n],["__file","blog.html.vue"]]),g=JSON.parse('{"path":"/blog.html","title":"Blog Design","lang":"en-US","frontmatter":{"icon":"edit","excerpt":"<p> 记录了该 BlogSite 的设计逻辑。同时，也会记录一些较为 tricky 的问题。 </p>","article":false,"description":"Blog Design Sidebar、Navbar等组件的交互逻辑借鉴了 Mister-Hope 的设计思路。同时，也会记录一些较为 tricky 的问题。 其实这里已经用到了一些 tricks。 Sidebar 对于一个目录 /path，有两种逻辑来显示它： 对于 /path 下的每个子目录，生成一个表项。该表项只包含链接，不可展开。路由至该子目录...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://zhangmxxx.github.io/BlogSite/blog.html"}],["meta",{"property":"og:site_name","content":"Site MallocSimenons"}],["meta",{"property":"og:title","content":"Blog Design"}],["meta",{"property":"og:description","content":"Blog Design Sidebar、Navbar等组件的交互逻辑借鉴了 Mister-Hope 的设计思路。同时，也会记录一些较为 tricky 的问题。 其实这里已经用到了一些 tricks。 Sidebar 对于一个目录 /path，有两种逻辑来显示它： 对于 /path 下的每个子目录，生成一个表项。该表项只包含链接，不可展开。路由至该子目录..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"en-US"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"Blog Design\\",\\"description\\":\\"Blog Design Sidebar、Navbar等组件的交互逻辑借鉴了 Mister-Hope 的设计思路。同时，也会记录一些较为 tricky 的问题。 其实这里已经用到了一些 tricks。 Sidebar 对于一个目录 /path，有两种逻辑来显示它： 对于 /path 下的每个子目录，生成一个表项。该表项只包含链接，不可展开。路由至该子目录...\\"}"]]},"headers":[{"level":2,"title":"Sidebar","slug":"sidebar","link":"#sidebar","children":[]},{"level":2,"title":"Navbar","slug":"navbar","link":"#navbar","children":[]},{"level":2,"title":"Articles on MainPage","slug":"articles-on-mainpage","link":"#articles-on-mainpage","children":[]},{"level":2,"title":"Tricks or Bugs","slug":"tricks-or-bugs","link":"#tricks-or-bugs","children":[]}],"readingTime":{"minutes":2.29,"words":687},"filePathRelative":"blog.md","autoDesc":true}');export{c as comp,g as data};
